---
layout: post
title: Pollard's Kangaroo Algorithm
subtitle: A random walk through Wikipedia  
cover-img: /assets/img/BLOG_COVERS/O.jpeg
thumbnail-img: /assets/img/BLOG_THUMBNAILS/14_bunny.jpg
tags: [math, computer science]
---

## introduction

Today, I thought it would be fun to click 4 random links starting from the Wikipedia page on [Markov chains](https://en.wikipedia.org/wiki/Markov_chain) and try to learn about or just comprehend what the topic ended up being. In the spirit of Markov, to do this, I generated 4 random numbers from 1 to the number of link elements on each page and was delighted to end up on a page titled [Pollard's kangaroo algorithm](https://en.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm). POllard's kangaroo algorithm is a way to solve the discrete logarithm problem (DLP) which is given as follows:

Find \\x \in Z_n s.t. \alpha^x = \beta\\ where *G* is a finite cyclic group of order *n* which is generated by the element \\ \alpha\\. 

## initial look at kangaroo algorithm ðŸ¦˜

Looking at the steps to the algorithm was puzzling. 

```
1. Choose set of integers to check for a solution in
2. Define a pseudorandom function mapping elements of the chosen group to the group G from the discrete log problem.
3. choose an integer N and compute first sequence of group elements. 

x_0 = alpha^b
x_{i+1} = x_i * alpha^(f(xi))
```

Already, this was flummoxing. While it makes sense that we are computing powers of alpha, why this pseudorandom generation function of a seemingly arbitrary set? Well, let's just continue on and see if it makes more sense...

```
4. d = sum from i=0 to N-1 of f(x_i). This means x_N = x_0 * alpha^d = alpha^(b+d)
```

Still not sure about these steps, but we'll turn to the second half of the algorithm.

```
5. A second sequence is computed, with y_0 = beta. Each element is y_{i+1} = y_i * alpha^(f(y_i))
6. d is ocmputed in the same manner as the sum from i=0 to n-1 of f(y_i) such that y_i = beta*alpha^(d_i).
```

Now, for the final step

```
The algorithm terminates either if there is

1. Collision: if y_j = x_N for some j, then x = b+d-d_j and the DLP is solved

2. Exceeding bound: if d > b-a + d, algorithm failed. Change S or f
```

## circling back
Nearly always I find the hardest question to answer is not how something works but *why* it works*. However, the *why* is hard to answer without the how so the initial legwork is not for nothing. So why do these steps help to solve the DLP? 




*Exceptions to this include lay ups in basketball and complicated board games that my brother enjoys

## applications in cryptography
why is prime number grouping chosen
